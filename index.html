<!DOCTYPE html>
<html>
<head>
    <title>Test Camera</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; }
        #debug { 
            position: fixed; 
            top: 10px; 
            left: 10px; 
            color: white; 
            font-family: Arial;
        }
    </style>
</head>
<body>
    <div id="debug">idk hl1</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// 1. Настройка сцены
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// 2. Освещение и карта
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(0, 10, 10);
scene.add(light);
scene.add(new THREE.AmbientLight(0x404040));

// Пол и стены
const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(20, 20),
    new THREE.MeshPhongMaterial({ color: 0x808080 })
);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

const wall = new THREE.Mesh(
    new THREE.BoxGeometry(10, 5, 1),
    new THREE.MeshPhongMaterial({ color: 0xB22222 })
);
wall.position.set(0, 2.5, -5);
scene.add(wall);

// 3. Настройка управления
let touchStartX = 0;
let touchStartY = 0;
let isRotating = false;
const rotationSpeed = 0.005;
const moveSpeed = 0.1;

// Начальные координаты камеры
camera.position.set(0, 3, 5);
camera.lookAt(0, 0, 0);

// 4. Обработчики касаний
document.addEventListener('touchstart', e => {
    e.preventDefault();
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
    isRotating = true;
});

document.addEventListener('touchmove', e => {
    e.preventDefault();
    if(!isRotating) return;

    const deltaX = e.touches[0].clientX - touchStartX;
    const deltaY = e.touches[0].clientY - touchStartY;

    // Поворот камеры
    camera.rotation.y -= deltaX * rotationSpeed;
    camera.rotation.x -= deltaY * rotationSpeed * 0.5;
    
    // Ограничение вертикального поворота
    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));

    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
});

document.addEventListener('touchend', () => {
    isRotating = false;
});

// 5. Движение через свайпы
let lastTouchY = 0;
document.addEventListener('touchstart', e => {
    lastTouchY = e.touches[0].clientY;
});

document.addEventListener('touchmove', e => {
    const deltaY = e.touches[0].clientY - lastTouchY;
    
    // Движение вперед/назад
    const direction = new THREE.Vector3(0, 0, -1);
    direction.applyQuaternion(camera.quaternion);
    camera.position.add(direction.multiplyScalar(-deltaY * 0.01));

    lastTouchY = e.touches[0].clientY;
});

// 6. Анимация
function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}

animate();

// 7. Адаптация под экран
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
